"""Handle flows as command arguments."""
import typing
from mitmproxy import command
from mitmproxy import ctx
from mitmproxy import flow
from mitmproxy import http
import time
import json
import random
#from threading import * 
import asyncio
import geopy
import geopy.distance
from syncer import sync
class MyAddon:
    def __init__(self):
        self.num = 0
        self.f1 = {}
        self.f2 = {}
        self.name = "Baseball Lover"
        self.latitude = '42.353071296625515'  
        self.longitude = '-71.1532377735582'
        self.dist = -1
        self.run = asyncio.Semaphore(0) 
        self.userNotFound = 1
    async def our_func(self, flows: typing.Sequence[flow.Flow]) -> None:
        for f in flows:
            if isinstance(f, http.HTTPFlow):
                if f.request.pretty_url.endswith("location"): 
                    #ctx.log.alert(f.request.urlencoded_form)
                    d=f.request.urlencoded_form
                    d['latitude'] = self.latitude
                    d['longitude'] = self.longitude
                    #ctx.log.alert(f.request.urlencoded_form)
                    self.f1=f
                if 'search' in f.request.pretty_url:
                    #ctx.log.alert(f.request.pretty_url)
                    d=f.request.query
                    d['limit'] = 200
                    f.request.query = d
                    self.f2=f
        #ctx.log.alert(f1.request.pretty_url)
        #ctx.log.alert(f2.response)
        self.num=self.num+1
        ctx.master.commands.call("replay.client", [self.f1])
        ctx.log.alert("First coord")
        ctx.log.alert(self.latitude)
        ctx.log.alert(self.longitude)
        await self.run.acquire()
        ctx.master.commands.call("replay.client", [self.f2])
        #await asyncio.sleep(5)
        # while self.run==1:
        #     continue
        # self.run=1
        await self.run.acquire()
        ctx.log.alert(self.dist)
        lat1 = self.latitude
        lon1 = self.longitude
        d = self.dist
        origin = geopy.Point(lat1, lon1)
        list1 = []
        for i in range(0,360):
            b = i
            destination = geopy.distance.distance(kilometers=d).destination(origin, b)
            list1.append(destination)
        #coord = destination.latitude, destination.longitude 

        #num = random.randint(0,360)
        lat1 = list1[111].latitude
        lon1 = list1[111].longitude
        ctx.log.alert("Second coord")
        ctx.log.alert(lat1)
        ctx.log.alert(lon1)
        self.f1.request.urlencoded_form['latitude'] = lat1
        self.f1.request.urlencoded_form['longitude'] = lon1
        ctx.master.commands.call("replay.client", [self.f1])
        await self.run.acquire()
        ctx.master.commands.call("replay.client", [self.f2])
        await self.run.acquire()
        ctx.log.alert(self.dist)
        d = self.dist
        origin = geopy.Point(lat1, lon1)
        list2 = []
        for i in range(0,360):
            b = i
            destination = geopy.distance.distance(kilometers=d).destination(origin, b)
            list2.append(destination)
        min1 = 99999999999
        closest_point1 = {}
        min2 = 99999999999
        closest_point2 = {}
        for l1 in list1:
            for l2 in list2:
                dist = geopy.distance.geodesic(l1,l2).km
                if(dist < min1):
                    min2 = min1
                    closest_point2=closest_point1
                    min1 = dist
                    closest_point1=l2
                elif(dist < min2):
                    min2 = dist
                    closest_point2=l2
        ctx.log.alert(min1)
        ctx.log.alert(min2)
        ctx.log.alert("Third Point choices:")
        ctx.log.alert(closest_point1.latitude)
        ctx.log.alert(closest_point1.longitude)
        ctx.log.alert(closest_point2.latitude)
        ctx.log.alert(closest_point2.longitude)
        self.f1.request.urlencoded_form['latitude'] = closest_point1.latitude
        self.f1.request.urlencoded_form['longitude'] = closest_point1.longitude
        ctx.master.commands.call("replay.client", [self.f1])
        await self.run.acquire()
        ctx.master.commands.call("replay.client", [self.f2])
        await self.run.acquire()
        ctx.log.alert(self.dist)
        d1 = self.dist
        self.f1.request.urlencoded_form['latitude'] = closest_point2.latitude
        self.f1.request.urlencoded_form['longitude'] = closest_point2.longitude
        ctx.master.commands.call("replay.client", [self.f1])
        await self.run.acquire()
        ctx.master.commands.call("replay.client", [self.f2])
        await self.run.acquire()
        ctx.log.alert(self.dist)
        d2 = self.dist
        # Change d and next origin here
        if d1 > d2:
            next_origin = closest_point2
            d = d2
        else:
            next_origin = closest_point1
            d = d1
        previous_circle = list2
        lat1 = next_origin.latitude
        lon1 = next_origin.longitude
        new_circle = []
        while (d>0.80467):
            ctx.log.alert("Inside the loop...")
            origin = geopy.Point(lat1, lon1)
            for i in range(0,360):
                b = i
                destination = geopy.distance.distance(kilometers=d).destination(next_origin, b)
                new_circle.append(destination)
            min1 = 99999999999
            closest_point1 = {}
            min2 = 99999999999
            closest_point2 = {}
            for l1 in previous_circle:
                for l2 in new_circle:
                    dist = geopy.distance.geodesic(l1,l2).km
                    if(dist < min1):
                        min2 = min1
                        closest_point2=closest_point1
                        min1 = dist
                        closest_point1=l2
                    elif(dist < min2):
                        min2 = dist
                        closest_point2=l2
            #Find distance for both locations and pick the smaller one
            # Change d and next origin here
            self.f1.request.urlencoded_form['latitude'] = closest_point1.latitude
            self.f1.request.urlencoded_form['longitude'] = closest_point1.longitude
            ctx.master.commands.call("replay.client", [self.f1])
            await self.run.acquire()
            ctx.master.commands.call("replay.client", [self.f2])
            await self.run.acquire()
            ctx.log.alert(self.dist)
            d1 = self.dist
            self.f1.request.urlencoded_form['latitude'] = closest_point2.latitude
            self.f1.request.urlencoded_form['longitude'] = closest_point2.longitude
            ctx.master.commands.call("replay.client", [self.f1])
            await self.run.acquire()
            ctx.master.commands.call("replay.client", [self.f2])
            await self.run.acquire()
            ctx.log.alert(self.dist)
            d2 = self.dist
            if d1 > d2:
                next_origin = closest_point2
                d = d2
            else:
                next_origin = closest_point1
                d = d1
            previous_circle = new_circle
            lat1 = next_origin.latitude
            lon1 = next_origin.longitude
            new_circle = []
        ctx.log.alert("Out of the Loop...")
        ctx.log.alert(d)
        #Draw 9 circles
        origin = geopy.Point(lat1, lon1)
        final_points = []
        prev_point = origin
        for i in range(0,9):
            b = i * 45
            
            d=0.80467
            prev_point = origin
            dist = 50
            itr = 0
            while(itr<4):
                time.sleep(1)
                destination = geopy.distance.distance(meters=dist).destination(origin, b)
                dist += 50
                
                # calculate distance here
                self.f1.request.urlencoded_form['latitude'] = destination.latitude
                self.f1.request.urlencoded_form['longitude'] = destination.longitude
                ctx.master.commands.call("replay.client", [self.f1])
                await self.run.acquire()
                await asyncio.sleep(1)
                ctx.master.commands.call("replay.client", [self.f1])
                await self.run.acquire()
                ctx.master.commands.call("replay.client", [self.f2])
                await self.run.acquire()
                ctx.log.alert(self.dist)
                d = self.dist
                if(d>0.80467):
                    itr +=1
                    if(d>0.80467 and itr == 1):
                        prev_point = destination
                    elif(d>0.80467 and itr == 4):
                        final_points.append(prev_point)
                else:
                    itr = 0
        ctx.log.alert("9 circle logic")
        for point in final_points:
            ctx.log.alert("------------")
            ctx.log.alert(point.latitude)
            ctx.log.alert(point.longitude)
            ctx.log.alert("------------")
    @command.command("1")
    def addheader(self, flows: typing.Sequence[flow.Flow]) -> None:
        asyncio.get_event_loop().create_task(self.our_func(flows))
    def response(self, flow: http.HTTPFlow):
        if 'search' in flow.request.pretty_url and self.num > 0:
            #ctx.log.alert(flow.response.text)
            #ctx.log.alert(self.f1.request.pretty_url)
            self.userNotFound = 1
            responseDict = json.loads(flow.response.text)
            for user in responseDict['elements']:
                if(user['user']['name'] == self.name):
                    #ctx.log.alert(user['user']['location']['distance_km'])
                    ctx.log.alert("User Found :)")
                    self.dist = user['user']['location']['distance_km']
                    self.userNotFound = 0
            self.run.release()
            if(self.userNotFound):
                ctx.log.alert("User Not Found :(")
        if flow.request.pretty_url.endswith("location"): 
            self.run.release()
            # given: lat1, lon1, b = bearing in degrees, d = distance in kilometers
addons = [
    MyAddon()
]